from typing import Iterable
from django.db import models
from datetime import timedelta
from arbiter.utils import set_property
import asyncio
import aiohttp
import re
from django.utils import timezone

class Property(models.Model):
    """
    Represents a systemd property that can be modified per systemd unit.
    Fields 'type' and 'operation' are used to specify how a string representing
    the property value should be cast, and how to judge a property value as more 'severe'.

    Example :
        name = 'CPUQuotaPerSecUSec' # name of valid systemd property that can be modified
        type = 'int'                # the data type of this property
        operation = '<'             # the more 'severe' property is the lesser one
    """

    class Meta:
        verbose_name_plural = "Properties"

    name = models.CharField(max_length=255, unique=True)

    class Type(models.TextChoices):
        INTEGER = ("int", "Integer")
        FLOAT = ("float", "Floating Point")
        BOOLEAN = ("bool", "Boolean")

    type = models.CharField(max_length=255, choices=Type.choices)

    class OP(models.TextChoices):
        GREATER = (">", "Greater Than")
        LESS = ("<", "Less Than")
        ENABLED = ("==", "Enabled")

    operation = models.CharField(max_length=255, choices=OP.choices)

    compare = {
        ">": lambda a, b: a > b,
        "<": lambda a, b: a < b,
        "==": lambda a, b: a and not b or a
    }

    cast = {
        "int": lambda x: int(x),
        "float": lambda x: float(x),
        "bool": lambda x: bool(x)
    }

    def __str__(self) -> str:
        return f"Name:{self.name} Type:{self.type} Operation:{self.operation}"


class Limit(models.Model):
    """
    Represents a systemd property with a value. Used to represent a resource limit to be
    applied to units.
    """

    UNSET_LIMIT = "-1"
    property = models.ForeignKey(Property, on_delete=models.CASCADE)
    value = models.CharField(max_length=255)

    def property_json(self) -> dict[str, str]:
        return {"name": self.property.name, "value": self.value}

    @staticmethod
    def compare(a: "Limit", b: "Limit") -> "Limit":
        a_val = Property.cast[a.property.type](a.value)
        b_val = Property.cast[b.property.type](b.value)
        return a if Property.compare[a.property.operation](a_val, b_val) else b

    def __str__(self) -> str:
        return f"{self.property.name} : {self.value}"
    
    @staticmethod
    async def _update_target_limits(limit, targets) -> None:
        async with aiohttp.ClientSession() as session:
            tasks = [set_property(target, session, limit.property_json()) for target in targets]
            await asyncio.gather(*tasks)

    def save(self, **kwargs) -> None:
        if self.pk:
            targets_to_update = list(self.target_set.all())
            asyncio.run(self._update_target_limits(self, targets_to_update))

        return super().save(**kwargs)


class Penalty(models.Model):
    """
    Represents a set of limits to be applied to a unit@host for a set period of time.
    """

    class Meta:
        verbose_name_plural = "Penalties"

    name = models.CharField(max_length=255, default="Penalty")
    limits = models.ManyToManyField(Limit)
    duration = models.DurationField(default=timedelta(minutes=5))
    repeat_offense_scale = models.FloatField(
        default=1.0,
        help_text="How much to scale penalty for repeat offenses (default 1.0)",
    )

    def __str__(self) -> str:
        return f"{self.name}"


class Policy(models.Model):
    """
    Represents a 'rule' that when broken is enforced. The policy applies to a domain of hosts, and
    has a penalty associated with it if it is broken. The query property is a PromQL query used to
    calculate when the policy has been violated, and is generated by the fields in query_params.
    However, the policy may be anything at all, represented as the 'raw' field in query_params.
    """

    class Meta:
        verbose_name_plural = "Policies"

    name = models.CharField(max_length=255, unique=True)
    domain = models.CharField(max_length=1024)
    description = models.TextField(max_length=1024, blank=True)
    penalty = models.ForeignKey(Penalty, on_delete=models.CASCADE)
    query_params = models.JSONField()
    timewindow = models.DurationField(
        default=timedelta(minutes=5),
        help_text="How far back Arbiter looks at usage (default 5m)",
    )
    query = models.TextField(max_length=1024, blank=True)
    grace_period = models.DurationField(
        default=timedelta(minutes=3),
        help_text="How long after a violation/penalty expires until the unit/host can violate this policy again",
    )
    lookback_window = models.DurationField(
        default=timedelta(hours=3),
        help_text="How far back arbiter looks for prior violations to scale penalty (default 3h)",
    )

    def build_query(self):
        if self.is_raw_query:
            return self.query_params["raw"]
        else:
            query = ""
            user_filters = f'instance=~"{self.domain}"'
            process_cpu_whitelist = ""
            process_mem_whitelist = ""
            timewindow = f"{int(self.timewindow.total_seconds())}s"

            if self.query_params.get("process_whitelist"):
                process_cpu_whitelist = (
                    f"- (rate(systemd_unit_proc_cpu_seconds"
                    f'{{{user_filters}, proc=~"{self.query_params["process_whitelist"]}"}}[{timewindow}]) or 0)'
                )
                process_mem_whitelist = (
                    f"- (avg_over_time(systemd_unit_proc_memory_bytes"
                    f'{{{user_filters} proc=~"{self.query_params["process_whitelist"]}"}}[{timewindow}]) or 0)'
                )

            if self.query_params.get("unit_whitelist"):
                user_filters += f', unit !~ "{self.query_params["unit_whitelist"]}"'

            if "cpu_threshold" in self.query_params:
                query += (
                    f"(sum by (unit, instance) (rate(systemd_unit_cpu_usage_ns{{{user_filters}}}"
                    f"[{timewindow}]){process_cpu_whitelist})"
                    f' / {1000**3 * self.query_params["cpu_threshold"]}) > 1.0'
                )
                # if both thresholds in params, put a or between the checks
                if "memory_threshold" in self.query_params:
                    query += " or "

            if "memory_threshold" in self.query_params:
                query += (
                    f"(sum by (unit, instance) (avg_over_time(systemd_unit_memory_current_bytes"
                    f"{{{user_filters}}}[{timewindow}]){process_mem_whitelist})"
                    f'/ {1024**3 * self.query_params["memory_threshold"]}) > 1.0'
                )
            return query

    @property
    def is_raw_query(self):
        return "raw" in self.query_params

    def save(self, **kwargs):
        self.query = self.build_query()
        return super().save(**kwargs)

    def __str__(self) -> str:
        return f"{self.name} on ({self.domain})"


class Target(models.Model):
    """
    Respresents a unit-host pairing which limits can be applied on
    """

    class Meta:
        verbose_name_plural = "Targets"
        constraints = [
            models.UniqueConstraint(fields=["unit", "host"], name="unique_target")
        ]

    unit = models.CharField(max_length=255)
    host = models.CharField(max_length=255)
    last_applied = models.ManyToManyField(Limit)

    def __str__(self) -> str:
        return f"{self.unit}@{self.host}"
    
    @property
    def uid(self) -> int | None:
        match = re.search(r'user-(\d+)\.slice', self.unit)
        if not match:
            return None
        return int(match.group(1))


class Violation(models.Model):
    """
    Represents a violation of a policy by a unit on a host. Also stipulates how long
    the unit is "in" violation
    """

    target = models.ForeignKey(Target, on_delete=models.CASCADE)
    policy = models.ForeignKey(Policy, on_delete=models.CASCADE)
    expiration = models.DateTimeField()
    timestamp = models.DateTimeField(auto_now=True)
    offense_count = models.IntegerField(default=1)

    @property
    def duration(self) -> timedelta:
        return self.expiration - self.timestamp

    @property
    def expired(self) -> bool:
        return self.expiration < timezone.now()
    
    def __str__(self) -> str:
        return (
            f"Unit {self.target.unit} violated {self.policy.name} on {self.target.host}"
        )


class Event(models.Model):
    """
    A logging model to show when events happen
    """

    class EventTypes(models.TextChoices):
        APPLY = ("Apply", "Limit Applied on a Target")
        EVALUATION = ("Eval", "Policies Evaluated")

    type = models.CharField(max_length=255, choices=EventTypes.choices)
    timestamp = models.DateTimeField(auto_now=True)
    data = models.JSONField()
